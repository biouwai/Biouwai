import{_ as o,c as n,a2 as s,j as t,a as e,o as r}from"./chunks/framework.0Bx0CPYg.js";const f=JSON.parse('{"title":"React","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/React/React.md","filePath":"front-end/React/React.md","lastUpdated":1728549424000}'),l={name:"front-end/React/React.md"};function i(c,a,d,u,h,p){return r(),n("div",null,a[0]||(a[0]=[s('<h1 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h1><h2 id="一、react-基础" tabindex="-1">一、React 基础 <a class="header-anchor" href="#一、react-基础" aria-label="Permalink to &quot;一、React 基础&quot;">​</a></h2><h3 id="_1-类组件为什么要绑定-this" tabindex="-1">1. 类组件为什么要绑定 this？ <a class="header-anchor" href="#_1-类组件为什么要绑定-this" aria-label="Permalink to &quot;1. 类组件为什么要绑定 this？&quot;">​</a></h3><p><strong>一般 this 指向全局变量，严格模式下 this 指向 undefined。因为类声明和类表达式是以严格模式运行，所以 React 的 this 指向 undefined。</strong></p><p><strong>解决方法</strong></p><ol><li>this.display = this.display.bind(this);将 this 绑到类组件上。</li><li>箭头函数可以免除这种行为，因为它使用的是词法 this 绑定，会将其自动绑定到定义他们的函数上下文。</li></ol><ul><li><a href="https://juejin.cn/post/6844903605984559118" target="_blank" rel="noreferrer">参考</a>：React 类中 this 为什么是 undefined ---&gt; 因为事件处理程序相当于将 this.handle 重新赋值给某个全局变量了。 受控组件 表单的值受 state 的控制 setState</li></ul><h3 id="_2-不可变值" tabindex="-1">2. 不可变值 <a class="header-anchor" href="#_2-不可变值" aria-label="Permalink to &quot;2. 不可变值&quot;">​</a></h3><p>● 不能直接操作 state，不能影响原来的 state 值 2. 可能是异步更新 ● 直接使用是异步更新： this.setState({ count: this.state.count + 1 }, () =&gt; { console.log(this.state.count); // 打印 count + 1 }) console.log(this.state.count) // 异步的，打印原先的 count 值 ● 但在 setTimeout 或者自定义 dom 事件中是同步的。 clickHander = () =&gt; { this.setState({ count: this.state.count + 1 }) console.log(this.state.count) // 打印+1 后的 count } componentDidMount() { document.body.addeventListener(&#39;click&#39;, this.clickHandler) } 3. 可能会被合并 ● 要想不合并，就传入函数 this.setState((prevState, props) =&gt; { return { count: preState.count + 1; } }) 生命周期 ● less</p><p>● common</p><p>二、React 高级特性 非受控组件 state 的值不受表单控制</p>',11),t("ol",null,[t("li",null,[t("p",null,"使用场景：")]),t("li",null,[t("p",null,[e("hha ● 必须好动操作 DOM，setState 实现不了 ● 文件上传"),t("input",{type:"file"}),e(" portal 让子组件在父组件外渲染 render() { return ReactDOM.createPortal(")]),t("div",{className:"modal"},"{this.props.children}"),e(", document.body //此时子组件容器就在 document.body 上 ) } context 公共信息传递给子组件 ")])],-1),t("p",null,"shouldComponentUpdate（SCU）",-1),t("ol",null,[t("li",null,"默认情况下，父组件更新，子组件也无条件更新 --> SCU 默认返回 true shouldComponetUpdate(nextProps, nextState) { if (nextProps.text !== this.props.text) { return true; // 只有 text 变化才重新渲染 } return false; }"),t("li",null,"SCU 要配合不可变值来写，不然 nextProps 可能等于 this.props 了 PureComponent（类组件）和 memo（函数组件） 相当于隐形的加了一个 SCU 生命周期对 props 进行了浅比较（比较了第一层） 高阶组件 HOC 在高阶组件里定义公共逻辑 Redux"),t("li",null,"单向数据流 ● dispatch(action) ● reducer -> newState ● subscribe 触发通知"),t("li",null,"react-edux 三、React Hooks")],-1)]))}const x=o(l,[["render",i]]);export{f as __pageData,x as default};

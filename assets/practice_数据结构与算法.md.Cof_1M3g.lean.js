import{_ as i,c as s,a2 as t,o as e}from"./chunks/framework.0Bx0CPYg.js";const l="/Biouwai/%E4%BA%8C%E5%8F%89%E6%A0%91.png",p="/Biouwai/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.png",o="/Biouwai/%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png",u=JSON.parse('{"title":"数据结构与算法","description":"","frontmatter":{},"headers":[],"relativePath":"practice/数据结构与算法.md","filePath":"practice/数据结构与算法.md","lastUpdated":1730364115000}'),r={name:"practice/数据结构与算法.md"};function n(h,a,d,c,E,k){return e(),s("div",null,a[0]||(a[0]=[t('<h1 id="数据结构与算法" tabindex="-1">数据结构与算法 <a class="header-anchor" href="#数据结构与算法" aria-label="Permalink to &quot;数据结构与算法&quot;">​</a></h1><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><ol><li><p>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p></li><li><p>什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？ 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。计算 a[k]的内存地址只需要用这个公式：</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a[k]_address </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> base_address </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type_size</span></span></code></pre></div><h2 id="递归" tabindex="-1">递归 <a class="header-anchor" href="#递归" aria-label="Permalink to &quot;递归&quot;">​</a></h2><p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。</p><ol><li><p>一个问题的解可以分解为几个子问题的解</p></li><li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</p></li><li><p>存在递归终止条件</p></li></ol><h2 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h2><p><img src="'+l+'" alt=""></p><ol><li><p><strong>满二叉树</strong>: 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。</p></li><li><p><strong>完全二叉树</strong>:编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。2n 为右子节点,2n+1 为左子节点 <img src="'+p+'" alt=""></p><blockquote><p>为什么要提出完全二叉树: 可以用数组表示</p></blockquote></li><li><p><strong>前中后序遍历</strong> 都是先左再右,名称对应根节点在前中后 <img src="'+o+'" alt=""></p><p>二叉树的前、中、后序遍历就是一个递归的过程</p></li><li><p>二叉查找树</p></li><li><p>平衡二叉树 二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p></li></ol><h2 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h2><p>堆是一种特殊的树 堆是一个完全二叉树； 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>',12)]))}const _=i(r,[["render",n]]);export{u as __pageData,_ as default};

import{_ as e,c as t,a2 as l,o as r}from"./chunks/framework.0Bx0CPYg.js";const i="/Biouwai/GCN1.jpg",o="/Biouwai/GCN.png",q=JSON.parse('{"title":"深度学习","description":"","frontmatter":{},"headers":[],"relativePath":"practice/深度学习.md","filePath":"practice/深度学习.md","lastUpdated":1730040151000}'),h={name:"practice/深度学习.md"};function n(d,a,c,s,u,p){return r(),t("div",null,a[0]||(a[0]=[l('<h1 id="深度学习" tabindex="-1">深度学习 <a class="header-anchor" href="#深度学习" aria-label="Permalink to &quot;深度学习&quot;">​</a></h1><h2 id="gcn" tabindex="-1">GCN <a class="header-anchor" href="#gcn" aria-label="Permalink to &quot;GCN&quot;">​</a></h2><h3 id="一、可以做什么" tabindex="-1">一、可以做什么 <a class="header-anchor" href="#一、可以做什么" aria-label="Permalink to &quot;一、可以做什么&quot;">​</a></h3><p>对特征进行提取</p><ol><li>结点分类 <img src="'+i+'" alt=""> 例：上图是一个社交网络，节点表示成员的特征，边表示有社交关系，颜色代表了他们所属的小团体。不依靠节点的特征，只通过图，在随机初始化权重之后，经过两次前向传播，可以大致将成员分对。</li></ol><h3 id="二、主要思想" tabindex="-1">二、主要思想 <a class="header-anchor" href="#二、主要思想" aria-label="Permalink to &quot;二、主要思想&quot;">​</a></h3><p>对于每个结点，我们都要考虑其所有邻居以及其自身所包含的特征信息</p><h3 id="三、聚合公式" tabindex="-1">三、聚合公式 <a class="header-anchor" href="#三、聚合公式" aria-label="Permalink to &quot;三、聚合公式&quot;">​</a></h3><p><img src="'+o+'" alt=""></p><ol><li>一个结点的特征 = [相邻结点的特征 × 权重(1/（自身的边个数 × 领居边个数）开方)]之和</li><li>聚合、归一化 <blockquote><p>问题：聚合下来之后怎么判断两节点是同一类呢</p></blockquote></li></ol><h2 id="svd" tabindex="-1">SVD <a class="header-anchor" href="#svd" aria-label="Permalink to &quot;SVD&quot;">​</a></h2><h3 id="一、-定义" tabindex="-1">一、 定义 <a class="header-anchor" href="#一、-定义" aria-label="Permalink to &quot;一、 定义&quot;">​</a></h3><h3 id="一、-思想" tabindex="-1">一、 思想 <a class="header-anchor" href="#一、-思想" aria-label="Permalink to &quot;一、 思想&quot;">​</a></h3><h3 id="一、-链接预测问题中的作用" tabindex="-1">一、 链接预测问题中的作用 <a class="header-anchor" href="#一、-链接预测问题中的作用" aria-label="Permalink to &quot;一、 链接预测问题中的作用&quot;">​</a></h3><h2 id="对比学习" tabindex="-1">对比学习 <a class="header-anchor" href="#对比学习" aria-label="Permalink to &quot;对比学习&quot;">​</a></h2><h3 id="一、思想" tabindex="-1">一、思想 <a class="header-anchor" href="#一、思想" aria-label="Permalink to &quot;一、思想&quot;">​</a></h3><ol><li>只对比高阶特征来判断数据</li></ol><h3 id="二、工作原理" tabindex="-1">二、工作原理 <a class="header-anchor" href="#二、工作原理" aria-label="Permalink to &quot;二、工作原理&quot;">​</a></h3><ol><li><p>数据扩增(增强)：例如同一张猫的照片可以通过调色裁剪等得到另外两张照片</p></li><li><p>编码：将每张图片丢进卷积神经网络中，都会得到一个向量表示。</p></li><li><p>损失函数最小化：希望正向数据对的向量表示尽可能的相似，负向数据对的向量表示尽可能的不同。以此去调整损失函数。</p></li></ol><h3 id="问题" tabindex="-1">问题： <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题：&quot;">​</a></h3><ol><li>为什么要输出成向量表示？</li></ol>',21)]))}const m=e(h,[["render",n]]);export{q as __pageData,m as default};
